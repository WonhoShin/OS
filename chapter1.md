**리눅스 커널의 입문서**

1. **kernel of linux**

2. 1. **혼자서 모든 리눅스 커널 시스템을 이해하는건 불가능 하다.**

   2. **중요한 것만 다루겠다**



---

1. **운영체제란?**

2. 1. **하드웨어 자원을 관리하며, 응용프로그램들을 지원해준다.**

   2. **오피스를 하나의 프로그램이 아니고 여러개로 한 이유**

   3. 1. **효율성을 위해 여러 프로그램으로 나눠놨다**

      2. **운영체제도 이를 위해 나눴다**
   4. **커널**

   5. 1. **메모리 resident, 부팅부터 종료 까지 계속 메모리에 유지됨**

      2. **그 말은 반대로 나머지는 메모리에 계속 유지되지 않음**
   6. **유틸리티 &lt;-&gt; 커널**

   7. 1. **디스크에 항상 유지되어있음 \(disk resident\)**

      2. **유저가 요청 시, 그때 메모리에 올라옴**

      3. **그러므로 command 라고도 불리움**
   8. **shell**

   9. 1. **유틸리티가 메모리에 언제올라오고, 내려가고 하는 것을 정리해줌**

      2. **유틸리티 중에 하나로써, 1차적 임무는 job control**
   10. **file**

   11. 1. **sequence of byte**

       2. **i/o device도 file 로 취급 \(standard file - 키보드, 마우스 등등\)**

       3. **dev = device의 약자**

**  
**

1. **커널-유틸리티-쉘-파일의 연관성**

2. 1. **부팅 시, 커널프로그램이 메모리로 올라옴, 쉘이 올라옴, 키보드 기다림, 사용자 가 입력을 하면 유틸리티를 메모리로 올림.**

**  
**

**  
**

1. **윈도우와 리눅스**

2. 1. **윈도우는 single user system, 리눅스는 muiti user system. 터미널이 여러 개 존재함. 멀티 유저라서 protection을 신경써야 함.**

   2. **자원을 사용할 때도 멀티유저의 경우 최소한으로 줄여서 사용해야한다.**

   3. **리눅스는 CUI, 윈도우는 GUI 기반의 운영체제, 윈도우가 자원을 많이 씀.. \(당연하지 GUI니까\)**

   4. **리눅스에서 protection이 문제가 되는건 multi-User 이기 때문에**

   5. 1. **다른 유저가 나에게 접근하는 것은 싫다. 그러므로 private information을 감춰야한다 \(메모리 or 디스크에 저장됨\)**

      2. **자원이 공유되기 때문에, 자원이 할당되면, 다른 사용자에게 접근하여 파일을 건들 수 있으므로 이걸 사전에 방지 하기 위해서 커널에게 i/o를 넘기고, 커널이 i/o를 관장해준다. \(이 때, 타당한 명령인지 확인\)**

      3. **i/o를 위해 커널의 function을 호출해야하고 이를 시스템 콜이라고 한다.**

      4. **cpu에 프로그램 카운터가 순서에 맞춰 memory에 주소를 보내면 메모리에서 올라가서 명령레지스터에 저장되서 실행된다.**

**  
**

1. 1. **이를 위해 새로운 개념을 도입**

   2. 1. **cpu에 한 binary bit \(mode bit\)를 도입**

      2. **bit가 0이면 유저모드, 1이면 커널모드**

      3. **커널모드이면 어떠한 메모리도 접근 가능, 0으로 되어있으면 자기 주소만 접근할 수 있도록 한다.**

      4. **커널모드이면, 어떤 명령도 수행할 수 있다. 유저모드는 i/o를 못함**

      5. **정리, 커널모드인 경우, 어떠한 메모리에도 접근 가능하며, op-code도 모두 실행할 수 있다. 반면에, 유저모드인 경우, local 메모리만 접근 가능하며 op-code도 제한된다.**

**  
**

1. **User 모드에서는 i/o가 제한된다.**

2. 1. **user mode로 mode bit이 될 경우, 보안검색을 받는다. 이 보안검색을 하는게 cp-momory 사이에 momory-managament unit 이라는 하드웨어가 있다. cpu로 부터 메모리로 가는 메모리버스에서 권한을 확인한다.**

   2. **이렇게 해야 사전에 illegal access가 차단된다.**

   3. **그렇다면 내 프로그램은 어떻게 i/o를 하는가? \(printf\(\) 같은거 쓰자낭...\)**

   4. 1. **i/o 명령 시, 읽을 디스크에 모든 인자들을 저장한다.**

      2. **source file 에서만 그렇게 보이고, 컴파일 해서 바이너리 file 보면 i/o statement 하나도 없다. 그게 있으면 cpu를 뺏겨버린다.**

      3. **그러므로 i/o를 하려면 커널의 function을 불러야 한다. \(system call\)**

      4. **컴파일 시, i/o가 나올때 마다 chmodk\( change cpu-mode to kernel \) 시스템콜을 수행시킴. 이 명령도 사실 유저가 할 수 없는 영역**

      5. **chmodk 는 privileged instruction이지만 컴파일러가 이를 수행, cpu를 뺏김, 이때 h/w 인터럽트가 걸림.\(trap이라고 지칭\). 이 후에 trap handler 가 작동, 이 루틴이 커널 안에 들어간다.**

      6. **정리, 내 프로그램이 i/o를 하려고함. i/o에 필요한 인자들을 디스크에 저장하고, chmodk 명령어를 실행하는데 이는 privileged 명령이므로 cpu를 뺏김. 그럼 나는 뺏기고 커널모드로 넘어가서 trap에 걸려버림. 이후에 trap handler가 i/o뭐 할지 보고 해줌 --system call의 과정**

      7. **이 후에, 커널이 permission을 체크함 \(이 디스크, 이 섹터에 권한이 있는지 확인\) 권한 있으면 해주고, 아니면 안해줌**

      8. **그 후에 trap으로 복귀, trap에서 userMode로 복귀**
   5. **모든 프로그램이 유저,커널 모드를 반복한다.**

**  
**

**  
**

1. **모든 프로그램은 두 가지 스택이 필요하다**

2. 1. **호출될 때, 지역변수가 생긴다. \(PUSH\), \(pop\)하게 된다. 스텍구조**

   2. **function이 호출되서 지역변수가 생기면 그게 리턴될 때 까지만 사용된다.**

   3. **유저스택, 커널스택**

   4. **프로그램의 실행은, 커널,유저 모드를 이동하며 이뤄진다.**

**  
**



**  
**

**\(CPU 동작과정\) \( 3-e에 딸린 자료\)**

**cpu에 program counter가 있고, 이번에 수행해야할 명령의 주소를 메모리로 보낸다, 메모리에서 그 주소에 있는 프로그램을 cpu의 명령register에 보낸다.op-code와 operands가 있는데 op-code를 보고 실행시킨다**

  


